# 网络相关没有特别难的，常见的了解下就没问题。


- 介绍Http2，优点和存在什么坑或问题（必考）
  - 优点：http2基于sdpy协议 ，专注于性能，目标是在用户和服务器间只用一个连接sdpy协议是google2009研发出来的，主要就是为了解决http1效率不高的问题。
    - 二进制帧数据。http2采用二进制进行数据传输，它把原来的header+body的数据格式拆分为一帧帧的二进制数据进行发送，而且收发都是无顺序的，这意味着不会出现堵塞。一帧帧数据上有个标识id,能够区分数据 ，浏览器可以据此组合出数据
    - header头数据压缩。和同一域名请求，只发送请求头不同的部分，这样就解决了http1中的问题 请求头过大而且重复发送。
    - 支持服务器端推送技术
    - 传输内容加密。http2不强制加密，但是chrome firefox都公开宣布只支持加密的http2 所以实事上http2是加密的
  - 缺点：主要是底层支持的tcp协议造成的问题，这些缺点http3中有解决办法
    - tcp 以及tcp+tls建立连接延时，两个握手延时
    - tcp包头阻塞
- HTTP报文的请求和返回会有几个部分（请求行、请求头、请求体）；每部分具体都有什么（常见的请求头）
  - 请求行 例如：GET /index.html HTTP/1.1
    - 请求方法字段： GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT
    - URL字段
    - HTTP协议版本：  HTTP/0.9  HTTP/1.0  HTTP/1.1  HTTP/2.0
  - 请求头  key-value的形式
    - User-Agent：产生请求的浏览器类型。
    - Accept：客户端可识别的内容类型列表。
    - Host：主机地址
  - 请求体 
    - post方法中，会把数据以key value形式发送请求
    - 发送回车符和换行符，通知服务器以下不再有请求头
   - [参考](https://www.cnblogs.com/qiang07/p/9304771.html)
- GET和POST的区别
 [参考](https://blog.csdn.net/qq_41939384/article/details/87628188) |
  -|
 分类 | GET |  POST  
 -|-|-
 后退按钮/刷新 | 无害 |  数据会被重新提交（浏览器应该告知用户数据会被重新提交） |
 书签 | 可收藏为书签 | 不可收藏为书签 |
 缓存 | 能被缓存 | 不能缓存 |
 编码类型 | application/x-www-form-urlencoded | pplication/x-www-form-urlencoded 或 multipart/form-dat |
 历史	| 参数保留在浏览器历史中。	| 参数不会保存在浏览器历史中。 |
 对数据长度的限制 |	是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 |	无限制。 |
 对数据类型的限制	| 只允许 ASCII 字符。	| 没有限制。也允许二进制数据。 |
 安全性	| 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！	POST 比 GET 更安全，因为  参数 | 不会被保存在浏览器历史或 web 服务器日志中。 |
 可见性 |	数据在 URL 中对所有人都是可见的。	| 数据不会显示在 URL 中。 |
- 输入url到页面加载全过程（必考）
  - 一个页面从无到有的变化就是前端的基本知识架构,具体有URL结构,DNS解析,DNS缓存,三次tcp握手,http请求,http响应,浏览器渲染,前后端交互,四次挥手等知识
  - URL结构 (协议,域名,路径,参数,哈希)
    - http:// 协议
    - www.baidu.com:80 // 域名+端口
    - get_data // 路径
    - parduct=1 // 参数
    - (#)title // 哈希(锚点)
  - DNS解析和缓存 (以google.com为例)
    - 根据google.com查找对应的IP地址,在查找过程中,浏览器先搜索自己的DNS缓存,其次搜索操作系统中的DNS缓存,在搜索操作系统中hosts文件,看有没有映射地址,在发送给LDNS(本地区域名服务器),LDNS将得到的IP地址返回给操作系统,同时自己将IP地址缓存起来,操作系统将IP地址返回给浏览器,同时自己也将IP地址缓存起来,自此,浏览器已经得到了域名对应的IP地址
  - 三次TCP握手 (建立连接通信)
    - 第一次握手,请求建立连接,客户端发送syn包到服务器,并进入SYN_SENT状态,等待服务器确认(您好,我想认识您)
    - 第二次握手,服务器收到syn包,必须确认客户的SYN,同时自己也发送一个SYN包,即SYN+ACK,服务器进入SYN_RECV状态 (好的,很高兴认识您)
    - 第三次握手,客户端收到服务器的SYN+SCK包,向服务器发送确认包ACK,自此,客户端和服务器进入ESTABLISHED(TCP连接成功),完成三次握手 (我也很高兴认识您)
  - http请求
    - 完整的HTTP请求消息包含了: 一个请求行,请求消息报头以及请求正文
    - 具体的请求方法主要有GET,POST,PUT,DELETE,HEAD,OPTIONS,TRACE
  - http响应
    - 完整的HTTP响应包含了: 状态行,响应消息报头以及响应正文
    - 其中常用的状态代码有,200,201,301,401,404,409,500等
  - 浏览器渲染
    - 浏览器会根据http响应来生成DOM树和CSSDOM树,这里就涉及到了两个主要知识点回流(Reflow)和重绘(Repaint)
    - 回流: 指元素的内容,结构,位置或尺寸发生了变化,需要重新计算样式和渲染第四次挥手,浏览器需要返回ACK表示同意 (恩,好的)树
    - 重绘: 指元素发生的改变只是影响了元素的一些外观之类的时候(背景色,边框颜色,文字颜色)
  - 四次挥手
    - 第一次挥手,浏览器发完数据后,发送FIN请求断开连接 (不早了,我该走了)
    - 第二次挥手,服务器发送ACK表示同意 (知道了)
    - 第三次挥手,服务器发送FIN (我也该走了)
    - 第四次挥手,浏览器需要返回ACK表示同意 (恩,好的)
  - 总结
    - 提问中的简单的一句网页输入地址到页面呈现所展现的知识点,基本都是前端必考的,其中URL,DNS解析,DNS缓存检查基本的网络知识,其中三次握手四次挥手,检查tcp协议,其中http请求,http响应检查http协议,其中前后端交互检查ajax(前后台数据交互),其中页面绘制检查重绘和回流  
- 介绍HTTPS；HTTP和HTTPS的区别（必考）[参考](https://www.jianshu.com/p/c036e9026a62)
  - HTTPS
    - 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
    - HTTPS协议的主要作用可以分为两种：一种是确认网站的真实性,进行身份认证；另一种就是身份认证成功后建立一个信息安全通道，来保证数据传输的安全。
  - http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
  - http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
  - http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
- HTTPS加密过程 [参考](https://www.jianshu.com/p/e30a8c4fa329)
  - 首先，客户端发起握手请求，以明文传输请求信息，包含版本信息，加密-套件候选列表，压缩算法候选列表，随机数，扩展字段等信息(这个没什么好说的，就是用户在浏览器里输入一个HTTPS网址，然后连接到服务端的443端口。)
  - 服务端的配置，采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。如果对公钥不太理解，可以想象成一把钥匙和一个锁头，只是世界上只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。
  - 服务端返回协商的信息结果，包括选择使用的协议版本 version，选择的加密套件 cipher suite，选择的压缩算法 compression method、随机数 random_S 以及证书。(这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。)
  - 客户端验证证书的合法性，包括可信性，是否吊销，过期时间和域名。(这部分工作是由客户端的SSL/TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警示框，提示证书存在的问题。如果证书没有问题，那么就生成一个随机值。然后用证书（也就是公钥）对这个随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。)
  - 客户端使用公匙对对称密匙加密，发送给服务端。(这部分传送的是用证书加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。)
  - 服务器用私钥解密，拿到对称加密的密匙。(服务端用私钥解密后，得到了客户端传过来的随机值，然后把内容通过该随机值进行对称加密，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。)
  - 传输加密后的信息，这部分信息就是服务端用私钥加密后的信息，可以在客户端用随机值解密还原。
  - 客户端解密信息，客户端用之前生产的私钥解密服务端传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。
- HTTP缓存控制（强缓存、协商缓存）；缓存相关的HTTP请求头（必考）[参考](https://www.jianshu.com/p/227cee9c8d15)
  - 强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。强制缓存生效时，http状态码为200。
  - 强缓存主要header属性有pragma，cache-control， expires
  - 当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。
  - 协商缓存主要的header属性有：ETag/If-Not-Match 、Last-Modified/If-Modified-Since，请求头和响应头需要成对出现
- 对跨域的了解，跨域怎么解决（必考）[参考](https://segmentfault.com/a/1190000011145364)
  - 通源策略： 所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。
  - 跨域是由于通源策略限制导致的
  - 通过jsonP跨域：通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。
  ```javascript
    var script = document.createElement('script');
    script.type = 'text/javascript';

    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);

    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
 ```
  - 通过跨域资源共享（CORS）
    - 普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。
  - nginx代理跨域 
  - Nodejs中间件代理跨域 比如在vue框架index.js上配置Proxy
- cors的返回头、cors预请求，什么时候会出发预请求（必考）[参考](https://www.jianshu.com/p/ebd498cc3c52)
  - cors预请求 正式通信之前，浏览器会先发送OPTION请求，进行预检，这一次的请求称为“预检请求”， 服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据
  - 什么时候会出发预请求： 发送非简单请求，如put，delete，或者自定义的头部字段，或者发送json格式数据。
- tcp的长连接和http2多路复用相关[参考](https://www.jianshu.com/p/ff8f0bd78942)
  - TCP经过三次握手建立连接，长连接是指不管有无数据包的发送都长期保持建立的连接；有长连接自然也有短连接，短连接是指双方有数据发送时，就建立连接，发送几次请求后，就主动或者被动断开连接。
  - HTTP/2 引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据。HTTP/2 对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。
- tcp拥塞控制和流量控制
- 三次握手四次挥手，为什么三次和四次[参考](https://www.jianshu.com/p/3cdc08c0fd43)
 - 见：输入url到页面加载全过程
 - 如果是两次握手 当网络原因服务端没有收到客户端的请求，且没有给客户端反馈。超时后客户端会再次向服务端发送请求。当网络畅通后服务器段收到最开始的请求并反馈给客户端。导致客户端认为自己未发送这个请求，服务端认为自己发送了一个新的请求，导致服务端性能浪费。
 - 4次挥手的原因： 通信双方断开连接分为2种情况：一方断开，和双方都断开，所以要比握手多一次
- 前端性能优化（必考）[参考](https://www.jianshu.com/p/fa25121c0f5f)
  - 使用CDN
  - 删除重复的脚本
  - 使用http缓存
  - 不要使用css表达式
  - 延迟加载
  - 预加载
